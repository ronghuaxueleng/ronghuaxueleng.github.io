<!DOCTYPE html>
<html>
    <head>
  <meta charset="utf-8">
  <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover" name="viewport" />
  <meta name="robots" content="index, follow">
  <!-- title -->
  
    
  <title>常用gulp插件介绍 - 白云雅阁</title>
    
  
  
  <!-- open graph -->
  <meta name="description" content="这里介绍一些gulp比较常用的插件，包括util工具类、stream相关、inject相关、Angular相关、压缩工具类、server相关、特定语言相关等。">
<meta property="og:type" content="article">
<meta property="og:title" content="常用gulp插件介绍">
<meta property="og:url" content="http://ronghuaxueleng.github.io/archives/47a159b2.html">
<meta property="og:site_name" content="白云雅阁">
<meta property="og:description" content="这里介绍一些gulp比较常用的插件，包括util工具类、stream相关、inject相关、Angular相关、压缩工具类、server相关、特定语言相关等。">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2016-08-09T00:00:00.000Z">
<meta property="article:modified_time" content="2025-03-09T08:43:48.255Z">
<meta property="article:author" content="ronghuaxueleng">
<meta property="article:tag" content="javascript">
<meta name="twitter:card" content="summary">
  <!-- canonical -->
  
  <link rel="canonical" href="http://ronghuaxueleng.github.io/archives/47a159b2.html">
  
  <!-- Favicon -->
  <link rel="shortcut icon" href="/img/favicon.ico">
  <link rel="apple-touch-icon" sizes="180x180" href="/img/apple-touch-icon.png">
  <!-- CSS -->
  
<link rel="stylesheet" href="/css/reset.css">

  
<link rel="stylesheet" href="/css/style.css">

  
<link rel="stylesheet" href="/css/markdown.css">

  
<link rel="stylesheet" href="/css/fonts.css">

<meta name="generator" content="Hexo 7.3.0"></head>

    <body>
        <div class="paper">
            <div class="paper-main">
                
                    <div class="post-header">
    <a class="logo" href="/">白云雅阁</a>
    <!-- <div class="logo"><a href="/" title="Len"><img src="/img/logo.svg" alt="Len" aria-label="logo" height="20"></a></div> -->
        <ul class="nav">
            
            <li><a href="/">Home</a></li>
            
            <li><a href="/archives">Archives</a></li>
            
        </ul>


    </a>
</div>

                
                <div class="post-main">
    
        <div class="post-main-title">
            常用gulp插件介绍
        </div>
        <div class="post-meta">
            2016-08-09 ｜ 
            
                <a href="/categories/%E8%87%AA%E5%8A%A8%E7%AE%A1%E7%90%86-gulp/"># 自动管理,gulp</a>
            
        </div>
        <!-- 圆角分类 -->
        <!-- <div class="tags"> -->
            <!--  -->
                <!-- <a href="/categories/%E8%87%AA%E5%8A%A8%E7%AE%A1%E7%90%86-gulp/">自动管理,gulp</a> -->
            <!--  -->
        <!-- </div> -->
        <div class="post-md">
            <p>这里介绍一些gulp比较常用的插件，包括util工具类、stream相关、inject相关、Angular相关、压缩工具类、server相关、特定语言相关等。</p>
<span id="more"></span>

<h3 id="util工具类"><a href="#util工具类" class="headerlink" title="util工具类"></a>util工具类</h3><p>这个分类下主要介绍一些辅助工具类的插件。</p>
<h4 id="gulp-load-plugins"><a href="#gulp-load-plugins" class="headerlink" title="gulp-load-plugins"></a><a href="https://www.npmjs.com/package/gulp-load-plugins">gulp-load-plugins</a></h4><p>顾名思义，本插件的功能就是帮你自动require你在<code>package.json</code>中声明的依赖。只要一句<code>var $ = require(&#39;gulp-load-plugins&#39;)()</code>，则<code>package.json</code>中声明的<code>gulp-</code>或<code>gulp.</code>开头的插件就会自动被放在变量<code>$</code>下面。如<code>$.util</code>就等于<code>require(&#39;gulp-util&#39;)</code>，而有两个连字符的插件则会自动命名为驼峰格式，如<code>$.taskListing</code>则等于<code>require(&#39;gulp-task-listing&#39;)</code>。有了这个插件，就不用一个一个的require了。这个插件还有一些常用的参数配置，这里列几个常用的：</p>
<ul>
<li><code>lazyload: true</code>，用到这个插件的时候再去require，默认为true。</li>
<li><code>rename: &#123;&#39;gulp-task-listing&#39;: &#39;list&#39;&#125;</code>，如果有些插件名字太长，可以使用该参数重命名。</li>
<li><code>scope: [&#39;dependencies&#39;]</code>，本插件默认会扫描<code>package.json</code>里的所有dependence，可以使用该参数进行限制。</li>
</ul>
<p>要使用这些参数只要在require的时候传入即可，如<code>require(&#39;gulp-load-plugins&#39;)(&#123;lazy: true&#125;)</code>。</p>
<h4 id="gulp-task-loader"><a href="#gulp-task-loader" class="headerlink" title="gulp-task-loader"></a><a href="https://www.npmjs.com/package/gulp-task-loader">gulp-task-loader</a></h4><p>这个插件的作用很简单，就是可以将gulpfile.js拆分成多个文件，放到目录下，是任务更清晰，结构更分明，使用方法如下：<br>clear.js</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&#x27;use strict&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> del = <span class="built_in">require</span>(<span class="string">&#x27;del&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> del.<span class="title function_">sync</span>(<span class="variable language_">this</span>.<span class="property">opts</span>.<span class="property">destDir</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>copy.js</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&#x27;use strict&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">gulp</span>.<span class="title function_">src</span>(<span class="variable language_">this</span>.<span class="property">opts</span>.<span class="property">publicDir</span>)</span><br><span class="line">     .<span class="title function_">pipe</span>(<span class="variable language_">this</span>.<span class="property">gulp</span>.<span class="title function_">dest</span>(<span class="variable language_">this</span>.<span class="property">opts</span>.<span class="property">destDir</span>));</span><br><span class="line">&#125;;</span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span>.<span class="property">dependencies</span> = [<span class="string">&#x27;clean&#x27;</span>];</span><br></pre></td></tr></table></figure>

<p>gulpfile.js</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&#x27;use strict&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> gulp = <span class="built_in">require</span>(<span class="string">&#x27;gulp&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> config = &#123;</span><br><span class="line">    <span class="attr">pkg</span>: <span class="built_in">require</span>(<span class="string">&#x27;./package.json&#x27;</span>),</span><br><span class="line">    <span class="attr">publicDir</span>: [<span class="string">&#x27;./&#123;public,public/**&#125;&#x27;</span>],</span><br><span class="line">    <span class="attr">destDir</span>: <span class="string">&#x27;dest&#x27;</span>,</span><br><span class="line">    <span class="attr">version</span>: <span class="string">&quot;0.01&quot;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">require</span>(<span class="string">&#x27;gulp-task-loader&#x27;</span>)(config);</span><br><span class="line">gulp.<span class="title function_">task</span>(<span class="string">&#x27;build&#x27;</span>, [<span class="string">&#x27;clean&#x27;</span>, <span class="string">&#x27;copy&#x27;</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>可以看到copy.js中最后有这样一行代码<code>module.exports.dependencies = [&#39;clean&#39;];</code>,这个是用做任务依赖的，只有前一个任务执行完毕后才能执行当前任务，使用起来还是很简单的</p>
<h4 id="gulp-task-listing"><a href="#gulp-task-listing" class="headerlink" title="gulp-task-listing"></a><a href="https://www.npmjs.com/package/gulp-task-listing">gulp-task-listing</a></h4><p>这个插件的作用也很容易猜，它可以打印出<code>gulpfile.js</code>中定义的所有task，这个插件我们在<a href="/2015/03/24/refactor-your-gulpfile/">重构你的gulpfile</a>这篇文章的最后介绍过，值得一提的是它还可以根据task的名字确定它是不是一个子task，比如带有<code>:</code>、<code>-</code>、<code>_</code>的task就被认为是子task。我一般把这个插件作为默认的task来调用，如</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gulp.<span class="title function_">task</span>(<span class="string">&#x27;default&#x27;</span>, [<span class="string">&#x27;help&#x27;</span>]);</span><br><span class="line">gulp.<span class="title function_">task</span>(<span class="string">&#x27;help&#x27;</span>, $.taskListing);</span><br></pre></td></tr></table></figure>

<p>这样，如果只执行<code>gulp</code>的话就会打印出所有定义好的task，非常实用。</p>
<h4 id="yargs"><a href="#yargs" class="headerlink" title="yargs"></a><a href="https://www.npmjs.com/package/yargs">yargs</a></h4><p>严格的说，<code>yargs</code>不是专门用于gulp的，它是Node中处理命令行参数的通用解决方案。只要一句代码<code>var args = require(&#39;yargs&#39;).argv;</code>就可以让命令行的参数都放在变量<code>args</code>上，非常方便。它可以处理的参数类型也是多种多样的：</p>
<ul>
<li>单字符的简单参数，如传入<code>-m=5</code>或<code>-m 5</code>，则可得到<code>args.m = 5</code>。</li>
<li>多字符参数（必须使用双连字符），如传入<code>--test=5</code>或<code>--test 5</code>，则可得到<code>args.test = 5</code>。</li>
<li>不带值的参数，如传入<code>--mock</code>，则会被认为是布尔类型的参数，可得到<code>args.mock = true</code>。</li>
</ul>
<p>除此之外，还支持很多其他类型的传参方式，具体可参考<a href="https://www.npmjs.com/package/yargs">它的文档</a>。</p>
<h4 id="gulp-util"><a href="#gulp-util" class="headerlink" title="gulp-util"></a><a href="https://www.npmjs.com/package/gulp-util">gulp-util</a></h4><p>gulp-util带有很多方便的函数，其中最常用的应该就是log了。<code>$.util.log()</code>支持传入多个参数，打印结果会将多个参数用空格连接起来。它与<code>console.log</code>的区别就是所有<code>$.util.log</code>的结果会自动带上时间前缀。另外，它还支持颜色，如<code>$.util.log($.util.colors.magenta(&#39;123&#39;));</code>打印出来的123是品红色的。其实<code>$.util.colors</code>就是一个<a href="https://github.com/sindresorhus/chalk">chalk</a>的实例，而chalk是专门用来处理命令行打印着色的一个工具。</p>
<h4 id="del"><a href="#del" class="headerlink" title="del"></a><a href="https://www.npmjs.com/package/del">del</a></h4><p>grunt自身提供一个<a href="https://github.com/gruntjs/grunt-contrib-clean">grunt-contrib-clean</a>用来处理支持glob匹配的删除，而del就是gulp上对应的工具。del支持和<code>gulp.src</code>参数同样的匹配，除此之外，它的第二个参数还支持一个回调函数，当删除完成以后执行，所以这是一个异步的删除。常用的调用方法为：<code>del([xxx], callback)</code>。</p>
<h4 id="gulp-bytediff"><a href="#gulp-bytediff" class="headerlink" title="gulp-bytediff"></a><a href="https://www.npmjs.com/package/gulp-bytediff">gulp-bytediff</a></h4><p>这是一个统计文件大小变化的工具，通常与压缩类工具放在一起实用，比如</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">gulp.<span class="title function_">src</span>(<span class="string">&#x27;**/*.html&#x27;</span>)</span><br><span class="line">    .<span class="title function_">pipe</span>($.bytediff.<span class="title function_">start</span>())</span><br><span class="line">    .<span class="title function_">pipe</span>($.<span class="title function_">minifyHtml</span>(&#123;<span class="attr">empty</span>: <span class="literal">true</span>&#125;))</span><br><span class="line">    .<span class="title function_">pipe</span>($.bytediff.<span class="title function_">stop</span>(bytediffFormatter))</span><br><span class="line">    .<span class="title function_">pipe</span>(gulp.<span class="title function_">dest</span>(<span class="string">&#x27;dist&#x27;</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">bytediffFormatter</span> (<span class="params">data</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> difference = (data.<span class="property">savings</span> &gt; <span class="number">0</span>) ? <span class="string">&#x27; smaller.&#x27;</span> : <span class="string">&#x27; larger.&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> data.<span class="property">fileName</span> + <span class="string">&#x27; went from &#x27;</span> +</span><br><span class="line">        (data.<span class="property">startSize</span> / <span class="number">1000</span>).<span class="title function_">toFixed</span>(<span class="number">2</span>) + <span class="string">&#x27; kB to &#x27;</span> +</span><br><span class="line">        (data.<span class="property">endSize</span> / <span class="number">1000</span>).<span class="title function_">toFixed</span>(<span class="number">2</span>) + <span class="string">&#x27; kB and is &#x27;</span> +</span><br><span class="line">        <span class="title function_">formatPercent</span>(<span class="number">1</span> - data.<span class="property">percent</span>, <span class="number">2</span>) + <span class="string">&#x27;%&#x27;</span> + difference;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在压缩的pipe前后加上<code>$.bytediff.start()</code>和<code>$.bytediff.stop(callback)</code>，即可统计压缩前后文件的变化。在callback中传入的参数data上，可以访问到很多变量，如文件名，变化前后的大小，变化百分比等等。</p>
<h4 id="gulp-print"><a href="#gulp-print" class="headerlink" title="gulp-print"></a><a href="https://www.npmjs.com/package/gulp-print">gulp-print</a></h4><p>这个插件的作用很简单，打印出stream里面的所有文件名，通常调试的时候比较需要。</p>
<h4 id="gulp-bump"><a href="#gulp-bump" class="headerlink" title="gulp-bump"></a><a href="https://www.npmjs.com/package/gulp-bump">gulp-bump</a></h4><p>这个插件也可以顾名思义：用来升级版本用的，废话不说，直接看例子吧：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> gulp</span><br><span class="line">    .<span class="title function_">src</span>(<span class="string">&#x27;package.json&#x27;</span>)</span><br><span class="line">    .<span class="title function_">pipe</span>($.<span class="title function_">bump</span>(options))</span><br><span class="line">    .<span class="title function_">pipe</span>(gulp.<span class="title function_">dest</span>(<span class="string">&#x27;dist&#x27;</span>));</span><br></pre></td></tr></table></figure>

<p>重点来看这里的options，我们可直接传递一个具体的version进去，也可以按照Node的版本规范传递一个type进去，让其自己生成对应的version：</p>
<ul>
<li><code>version</code>，直接传递要升级到的版本号，如<code>1.2.3</code>。</li>
<li><code>type</code>，可接受的值包括下面四个，倘若现在的版本号为<code>1.2.3</code>，则对应的新版本号为：<ul>
<li>prerelease：<code>1.2.3-0</code></li>
<li>patch：<code>1.2.4</code></li>
<li>minor：<code>1.3.0</code></li>
<li>major：<code>2.0.0</code></li>
</ul>
</li>
</ul>
<p>最终这个升级后的版本号会反映在<code>package.json</code>中，当然，你也可以在gulp.src中传入更多的文件（如<code>bower.json</code>）来替换更多的文件。</p>
<h4 id="gulp-header"><a href="#gulp-header" class="headerlink" title="gulp-header"></a><a href="https://www.npmjs.com/package/gulp-header">gulp-header</a></h4><p>这个工具用来在压缩后的JS、CSS文件中添加头部注释，你可以包含任意想要的信息，通常就是作者、描述、版本号、license等，比如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getHeader</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> pkg = <span class="built_in">require</span>(<span class="string">&#x27;package.json&#x27;</span>);</span><br><span class="line">    <span class="keyword">var</span> template = [<span class="string">&#x27;/**&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27; * &lt;%= pkg.name %&gt; - &lt;%= pkg.description %&gt;&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27; * @authors &lt;%= pkg.authors %&gt;&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27; * @version v&lt;%= pkg.version %&gt;&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27; * @link &lt;%= pkg.homepage %&gt;&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27; * @license &lt;%= pkg.license %&gt;&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27; */&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;&#x27;</span></span><br><span class="line">    ].<span class="title function_">join</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> $.<span class="title function_">header</span>(template, &#123;</span><br><span class="line">        <span class="attr">pkg</span>: pkg</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个函数将<code>package.json</code>中的各种信息提取出来，变成头部注释，只要在压缩的pipe中调用<code>.pipe(getHeader())</code>即可。</p>
<h3 id="stream相关"><a href="#stream相关" class="headerlink" title="stream相关"></a>stream相关</h3><p>这个部分主要介绍一些跟stream操作有关的插件。</p>
<h4 id="gulp-filter"><a href="#gulp-filter" class="headerlink" title="gulp-filter"></a><a href="https://www.npmjs.com/package/gulp-filter">gulp-filter</a></h4><p>gulp-filter可以把stream里的文件根据一定的规则进行筛选过滤。比如<code>gulp.src</code>中传入匹配符匹配了很多文件，可以把这些文件pipe给gulp-filter作二次筛选，如<code>gulp.src(&#39;**/*.js&#39;).pipe($.filter(**/a/*.js))</code>，本来选中了所有子文件下的js文件，经过筛选后变成名为a的子文件夹下的js文件。那有人要问了，为什么不直接将需要的筛选传入<code>gulp.src</code>，干嘛要多筛选一步呢？这里面有两种情况：</p>
<ul>
<li><code>gulp.src</code>与<code>$.filter</code>中间可能需要别的处理，比如我对所有文件做了操作1以后，还需要筛选出一部分做操作2。</li>
<li>第二种情况就要谈到gulp-filter的另外一个特性：筛选之后还可以restore回去。比如我对所有文件做了操作1，筛选了一部分做操作2，最后要把所有的文件都拷贝到最终的位置。代码如下：</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> filter = $.<span class="title function_">filter</span>(<span class="string">&#x27;**/a/*.js&#x27;</span>);</span><br><span class="line">gulp.<span class="title function_">src</span>(<span class="string">&#x27;**/*.js&#x27;</span>)</span><br><span class="line">    .<span class="title function_">pipe</span>(<span class="title function_">action1</span>())</span><br><span class="line">    .<span class="title function_">pipe</span>(filter)</span><br><span class="line">    .<span class="title function_">pipe</span>(<span class="title function_">action2</span>())</span><br><span class="line">    .<span class="title function_">pipe</span>(filter.<span class="title function_">restore</span>())</span><br><span class="line">    .<span class="title function_">pipe</span>(gulp.<span class="title function_">dest</span>(<span class="string">&#x27;dist&#x27;</span>))</span><br></pre></td></tr></table></figure>

<p>可以看到，如果没有restore这个操作，那么拷贝到最终位置的文件将只包含被过滤出来的文件，这样一restore，所有的文件都被拷贝了。</p>
<h4 id="gulp-flatten"><a href="#gulp-flatten" class="headerlink" title="gulp-flatten"></a><a href="https://www.npmjs.com/package/gulp-flatten">gulp-flatten</a></h4><p>gulp-flatten非常实用，可能知道别的库中flatten函数的同学已经猜到它是干嘛的了。比如<code>gulp.src(&#39;**/*.js&#39;)</code>匹配了很多文件，包括<code>a/b/c.js</code>，<code>d/e.js</code>，<code>f/g/h/i/j/k.js</code>，<code>l.js</code>，这些文件的层级都不一样，一旦我们将这个文件pipe给<code>$.flatten()</code>，则所有的文件夹层级都会去掉，最终的文件将是<code>c.js</code>，<code>e.js</code>，<code>k.js</code>，<code>l.js</code>，在一些场景下还是非常有用的。</p>
<h4 id="gulp-plumber"><a href="#gulp-plumber" class="headerlink" title="gulp-plumber"></a><a href="https://www.npmjs.com/package/gulp-plumber">gulp-plumber</a></h4><p>这个插件的作用简单来说就是一旦pipe中的某一steam报错了，保证下面的steam还继续执行。因为pipe默认的onerror函数会把剩下的stream给unpipe掉，这个插件阻止了这种行为。那它一般用于哪种场景呢？比如，代码每次build之前要跑一遍jshint和jscs来确保所有代码都符合规范，但一旦某些代码不符合规范，整个build流程就会停止，这个时候就需要gulp-plumber出场了。如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">gulp.<span class="title function_">task</span>(<span class="string">&#x27;build&#x27;</span>, [<span class="string">&#x27;jslint&#x27;</span>, <span class="string">&#x27;xxxx&#x27;</span>]);</span><br><span class="line">gulp.<span class="title function_">task</span>(<span class="string">&#x27;jslint&#x27;</span>, <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> gulp</span><br><span class="line">        .<span class="title function_">src</span>(config.<span class="property">js</span>.<span class="property">all</span>)</span><br><span class="line">        .<span class="title function_">pipe</span>($.<span class="title function_">plumber</span>())</span><br><span class="line">        .<span class="title function_">pipe</span>($.<span class="title function_">jshint</span>())</span><br><span class="line">        .<span class="title function_">pipe</span>($.<span class="title function_">jscs</span>()); </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>这样，一旦jshint或jscs报错，整个build流程还是可以继续走下去的，而且gulp-plumber会给出一个报错提醒我们：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[16:52:36] Plumber found unhandled error:</span><br><span class="line"> Error in plugin &#x27;gulp-jshint&#x27;</span><br><span class="line">Message:</span><br><span class="line">    JSHint failed for: xxxx.js</span><br></pre></td></tr></table></figure>

<h4 id="gulp-if"><a href="#gulp-if" class="headerlink" title="gulp-if"></a><a href="https://www.npmjs.com/package/gulp-if">gulp-if</a></h4><p>这个插件的功能也很简单，可以条件性的添加stream，如<code>.pipe($.if(flag, action1()))</code>，则只会在<code>flag</code>变量为true时才会将<code>action1()</code>添加到stream中去。其实不用这个插件也可以达到类似的效果，那就是gulp-util里有一个函数叫做<code>noop()</code>，也就是no operation，这个函数其实是返回一个什么都不干的空stream。利用这个函数我们可以这么写：<code>.pipe(flag ? action1() : $.util.noop())</code>，与上例的效果是一样的。</p>
<h4 id="merge-stream"><a href="#merge-stream" class="headerlink" title="merge-stream"></a><a href="https://www.npmjs.com/package/merge-stream">merge-stream</a></h4><p>一个gulp的task只能返回一个stream，但有的时候有这么一种情景：有两类文件，它们的原始位置和处理后的位置都是不同的，但它们的处理流程相同。由于<code>gulp.src</code>和<code>gulp.dest</code>的参数不同，我们就需要写两个task来分别完成这个任务，一方面略显重复，另一方面逻辑上来讲这两个task本来就是处理同样的事情的。这种情况就需要merge-stream登场了，它的作用就是将多个stream合成一个返回。比如下面这个例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> merge = <span class="built_in">require</span>(<span class="string">&#x27;merge-stream&#x27;</span>);</span><br><span class="line">gulp.<span class="title function_">task</span>(<span class="string">&#x27;jade&#x27;</span>, <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> stream1 = <span class="title function_">jade</span>(src1, dest1);</span><br><span class="line">    <span class="keyword">var</span> stream2 = <span class="title function_">jade</span>(src2, dest2);</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">merge</span>(stream1, stream2);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">jade</span> (<span class="params">src, dest</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> gulp</span><br><span class="line">        .<span class="title function_">src</span>(src)</span><br><span class="line">        .<span class="title function_">pipe</span>($.<span class="title function_">jade</span>())</span><br><span class="line">        .<span class="title function_">pipe</span>(gulp.<span class="title function_">dest</span>(dest));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，处理的流程被提取出来放入一个函数，它接受两个参数，分别是src和dest。然后在task中直接调用这个函数生成两个stream，然后返回merge-stream合并后的结果。</p>
<h4 id="run-sequence"><a href="#run-sequence" class="headerlink" title="run-sequence"></a><a href="https://www.npmjs.com/package/run-sequence">run-sequence</a></h4><p>gulp里的task都是异步并发执行的，有的时候我们需要一连串的task按顺序执行，这时就需要run-sequence登场了。它的调用很简单：<code>runSequence(&#39;task1&#39;, &#39;task2&#39;, [&#39;task3&#39;, &#39;task4&#39;], &#39;task5&#39;)</code>，这里的task都是gulp定义好的task名称，task1完成后才会执行task2，以此类推。注意到task3和task4被放在中括号里了，这表明，task3和task4可以并发执行的，但两个都执行完后才会执行task5。这里要说明的是，每个task要么返回一个stream，即<code>return gulp.src().pipe().pipe()</code>，要么支持回调函数，即<code>gulp.task(&#39;task1&#39;, function (done) &#123; action1(done); &#125;)</code>，满足了这两点才能保证正常的执行顺序，因为这是gulp对<a href="https://github.com/gulpjs/gulp/blob/master/docs/API.md#async-task-support">异步task的基本要求</a>。</p>
<h3 id="inject相关"><a href="#inject相关" class="headerlink" title="inject相关"></a>inject相关</h3><p>这个部分主要介绍一些将JS&#x2F;CSS自动插入到HTML的相关插件。</p>
<h4 id="wiredep"><a href="#wiredep" class="headerlink" title="wiredep"></a><a href="https://www.npmjs.com/package/wiredep">wiredep</a></h4><p>wiredep就是wire dependence的意思，它的作用就是把<code>bower.json</code>中声明的dependence自动的包含到HTML中去。要插入文件，wiredep需要解决两个问题：</p>
<ul>
<li>插入的位置：wiredep通过识别HTML中的注释来识别插入位置，如</li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- bower:css --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- endbower --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- bower:js --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- endbower --&gt;</span></span><br></pre></td></tr></table></figure>

<p>不同类型的文件被插入到不同的区块。</p>
<ul>
<li>插入什么文件：要插入的文件列表自然来自<code>bower.json</code>，每个bower安装的依赖库，根目录下边都有一个自己的<code>bower.json</code>文件，其中的<code>main</code>字段指明了使用这个库需要包含的文件，wiredep最终包含的文件列表就来自这个字段。有些情况下，库自身的<code>bower.json</code>的main字段可能会多包含文件或少包含文件，如果想要定制这个列表，则可以在自己的<code>bower.json</code>中使用<code>overrides</code>字段，如下面的代码覆盖了<code>mdi</code>这个库的<code>main</code>字段。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;overrides&quot;</span>: &#123;</span><br><span class="line">  <span class="string">&quot;mdi&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;main&quot;</span>: [</span><br><span class="line">      <span class="string">&quot;css/materialdesignicons.css&quot;</span></span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<p>wiredep插件支持很多参数，常用的主要有两个：</p>
<ul>
<li>bowerJson：指定<code>bower.json</code>的内容，注意这个字段不是<code>bower.json</code>文件的位置，这个参数需要使用require后的结果赋值：<code>require(&#39;bower.json&#39;)</code>。</li>
<li>directory：指定存放bower安装后的依赖包的路径，通常是bower_components。注意最终插入到HTML中的文件列表的路径是index.html文件相对于本文件夹的相对路径。</li>
</ul>
<p>使用wiredep也比较简单，直接把它传入到stream中即可，如<code>gulp.src(&#39;index.html&#39;).pipe(wiredep(options))</code>。</p>
<h4 id="gulp-inject"><a href="#gulp-inject" class="headerlink" title="gulp-inject"></a><a href="https://www.npmjs.com/package/gulp-inject">gulp-inject</a></h4><p>这个插件的作用与wiredep类似，不同的是可以自己任意指定需要插入文件的列表。它同样是利用注释来寻找插入的位置，它识别的默认注释为<code>&lt;!-- inject:js --&gt;</code>，但更加智能：</p>
<ul>
<li>支持各种模板语言：可以根据<code>gulp.src</code>指定的源文件自动识别注释和插入内容，除了支持HTML外，还支持jade、haml等。若源为jade文件，则识别的注释为<code>//- inject:js</code>，插入的内容为：<code>script(src=&quot;&lt;filename&gt;.js&quot;)</code>。</li>
<li>配置非常灵活：<ul>
<li>name：默认识别的注释标签格式为<code>&lt;!-- name:ext --&gt;</code>，这里的name默认值就是“inject”，而ext的默认值是要插入的文件的扩展名。那么name属性可配置意味着可以添加自定义的插入区块，如<code>&lt;!-- production:js --&gt;</code>，这个标签可以只插入生产环境需要包含的JS文件。</li>
<li>starttag和endtag：支持自定义需要识别的注释内容。</li>
<li>addPrefix和addSuffix：支持在插入文件的路径上自定义前缀、后缀。</li>
<li>relative：指定插入文件的路径是否为相对路径。</li>
<li>ingorePath：指定插入文件的路径前面会忽略掉指定的路径。</li>
<li>read：这个参数通常给false，不需要真正的去读取文件。</li>
</ul>
</li>
</ul>
<p>这个插件的使用场景通常是，我们需要index里有多个区块，比如上面name的例子，只有当为production环境编译的时候才去包含相关的文件。</p>
<h4 id="gulp-useref-与-gulp-rev、gulp-rev-replace"><a href="#gulp-useref-与-gulp-rev、gulp-rev-replace" class="headerlink" title="gulp-useref 与 gulp-rev、gulp-rev-replace"></a><a href="https://www.npmjs.com/package/gulp-useref">gulp-useref</a> 与 <a href="https://www.npmjs.com/package/gulp-rev">gulp-rev</a>、<a href="https://www.npmjs.com/package/gulp-rev-replace">gulp-rev-replace</a></h4><p>这三个工具之所以放在一起讲，是因为它们一般都是一起使用的。它们要解决什么问题呢？通过上面的wiredep也好，gulp-inject也好，插入了一堆JS、CSS文件到HTML中，一旦部署到生产环境，这么多文件必然是要合并压缩的。光是压缩还不够，为了解决缓存问题，每次合并压缩后要给最终的文件加hash，这样每次文件内容一变动，hash也会跟着变动，就不存在浏览器依然使用缓存的老文件的问题。这样得到最终的文件以后，肯定还要将这个文件替换回HTML中去，一大堆的script和link标签替换成最终合并压缩带hash的版本。</p>
<p>前面啰啰嗦嗦的一大堆工作就是这三个插件要解决的问题了。首先，gulp-useref根据注释将HTML中需要合并压缩的区块找出来，对区块内的所有文件进行合并。<strong>注意：它只负责合并，不负责压缩！</strong>所以合并出来的文件我们要自行压缩，压缩以后调用gulp-rev负责在文件名后追加hash。最后调用gulp-rev-replace负责把最终的文件名替换回HTML中去。扯了大半天，还是直接上例子吧。先来看看HTML中的注释：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- build:css static/styles/lib.css --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- bower:css --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- endbower --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- endbuild --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- build:css static/styles/app.css --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- inject:css --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- endinject --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- endbuild --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- build:js static/js/lib.js --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- bower:js --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- endbower --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- endbuild --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- build:js static/js/app.js --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- inject:js --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- endinject --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- endbuild --&gt;</span></span><br></pre></td></tr></table></figure>

<p>gulp-useref识别的就是build开头的注释，build后面首先跟的是类型扩展名，然后后面的路径就是build区块中的所有文件进行合并后的文件路径，这个相对路径是相对于这个HTML的路径。上面的例子中我们用build区块把bower和inject进来的文件包起来，这些文件就可以被gulp-useref合并了。再来看gulp中useref相关task的定义：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> assets = $.useref.<span class="title function_">assets</span>(&#123;<span class="attr">searchPath</span>: <span class="string">&#x27;app/src/&#x27;</span>&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> cssFilter = $.<span class="title function_">filter</span>(<span class="string">&#x27;**/*.css&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> jsAppFilter = $.<span class="title function_">filter</span>(<span class="string">&#x27;**/app.js&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> jslibFilter = $.<span class="title function_">filter</span>(<span class="string">&#x27;**/lib.js&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> gulp</span><br><span class="line">    .<span class="title function_">src</span>(<span class="string">&#x27;index.html&#x27;</span>)</span><br><span class="line">    .<span class="title function_">pipe</span>(assets)</span><br><span class="line">    .<span class="title function_">pipe</span>(cssFilter)</span><br><span class="line">    .<span class="title function_">pipe</span>($.<span class="title function_">csso</span>())</span><br><span class="line">    .<span class="title function_">pipe</span>(cssFilter.<span class="title function_">restore</span>())</span><br><span class="line">    .<span class="title function_">pipe</span>(jsAppFilter)</span><br><span class="line">    .<span class="title function_">pipe</span>($.<span class="title function_">uglify</span>())</span><br><span class="line">    .<span class="title function_">pipe</span>(<span class="title function_">getHeader</span>())</span><br><span class="line">    .<span class="title function_">pipe</span>(jsAppFilter.<span class="title function_">restore</span>())</span><br><span class="line">    .<span class="title function_">pipe</span>(jslibFilter)</span><br><span class="line">    .<span class="title function_">pipe</span>($.<span class="title function_">uglify</span>())</span><br><span class="line">    .<span class="title function_">pipe</span>(jslibFilter.<span class="title function_">restore</span>())</span><br><span class="line">    .<span class="title function_">pipe</span>($.<span class="title function_">rev</span>())</span><br><span class="line">    .<span class="title function_">pipe</span>(assets.<span class="title function_">restore</span>())</span><br><span class="line">    .<span class="title function_">pipe</span>($.<span class="title function_">useref</span>())</span><br><span class="line">    .<span class="title function_">pipe</span>($.<span class="title function_">revReplace</span>())</span><br><span class="line">    .<span class="title function_">pipe</span>(gulp.<span class="title function_">dest</span>(<span class="string">&#x27;dist&#x27;</span>));</span><br></pre></td></tr></table></figure>

<p>首先一上来，先调用<code>$.useref.assets()</code>函数，这个函数返回一个stream，包含已经合并后的文件。可以尝试在第9行后面加上前面介绍过的gulp-print插件<code>.pipe($.print())</code>，打印出stream里的文件，发现就是前面HTML中4个build注释块后面的4个文件。注意这里调用的时候跟了一个<code>searchPath</code>的参数，它的用处就是指定从哪个路径开始寻找build区块底下的文件。比如build区块底下有这么一行&#96;&#96;，那最终gulp-useref将从这个路径<code>app/src/static/js/a.js</code>找到这个文件。第3到5行定义了3个filter，这主要是为了后面压缩准备的。下面正式看stream的pipe流程。先选出要处理的HTML文件，然后调用刚才得到的<code>assets</code>得到合并后的4个文件，第10到12行筛选出合并后的CSS文件进行压缩（压缩类插件下篇文章再讲），第13到16行筛选出app.js进行压缩，第17到19行筛选出lib.js进行压缩。之所以要区别对待app.js和lib.js，是因为app.js是我们自己写的代码，压缩后要加上header（第15行，使用前面介绍过的gulp-header插件），而lib.js是第三方的各种库，直接压缩即可。后面调用gulp-rev给压缩后的4个文件加hash，然后调用<code>assets.restore()</code>将src源换回HTML文件，这是为了后面调用<code>$.useref()</code>，因为<code>$.useref()</code>做替换的src源是HTML文件，同样后面调用gulp-rev-replace将带hash的文件替换回HTML，它要求的src源也必须是HTML文件。这里的顺序很重要，因为这几个插件接受的源不一样，gulp-rev接受的是JS、CSS文件，而gulp-useref和gulp-rev-replace接受的是HTML。还有一个问题：gulp-rev-replace是怎么知道gulp-rev进行hash前后的文件名对应关系呢？其实gulp-rev会生成一个manifest的文件，内容是类似下面的JSON：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;static/styles/lib.css&quot;</span>: <span class="string">&quot;static/styles/lib-d41d8cd98f.css&quot;</span></span><br><span class="line">    <span class="string">&quot;static/js/lib.js&quot;</span>: <span class="string">&quot;static/js/lib-273c2cin3f.js&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然这个文件默认是不会生成在文件系统里的，可以通过<code>.pipe($.rev.manifest())</code>将这个文件保存到本地。有了这个文件，gulp-rev-replace甚至可以脱离gulp-rev独立工作哦！</p>
<h4 id="gulp-html-replace"><a href="#gulp-html-replace" class="headerlink" title="gulp-html-replace"></a><a href="https://www.npmjs.com/package/gulp-html-replace">gulp-html-replace</a></h4><p>gulp-html-replace同样是识别以build开头的注释,与<a href="https://www.npmjs.com/package/gulp-useref">gulp-useref</a>不同的是不会对build区块中的所有文件进行合并，而是根据配置直接替换掉build区块中的内容下面以一个例子做说明：</p>
<p>html片段</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- build:css --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">&quot;css/one.css&quot;</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">&quot;css/two.css&quot;</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- endbuild --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- build:vendorJs --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">src</span>=<span class="string">&quot;js/one.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">src</span>=<span class="string">&quot;js/two.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- endbuild --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>相关任务：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">gulp.<span class="title function_">src</span>(<span class="string">&#x27;index.html&#x27;</span>)</span><br><span class="line">    .<span class="title function_">pipe</span>(<span class="title function_">htmlreplace</span>(&#123;</span><br><span class="line">        <span class="string">&#x27;css&#x27;</span>: <span class="string">&#x27;styles.min.css&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;vendorJs&#x27;</span>: <span class="string">&#x27;/js/vendor.js&#x27;</span></span><br><span class="line">    &#125;))</span><br><span class="line">    .<span class="title function_">pipe</span>(gulp.<span class="title function_">dest</span>(<span class="string">&#x27;dest/&#x27;</span>));</span><br></pre></td></tr></table></figure>
<p>执行任务后的html片段：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;styles.min.css&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;/js/vendor.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>很简单，不用再做过多的说明</p>
<h4 id="gulp-rev-hash2"><a href="#gulp-rev-hash2" class="headerlink" title="gulp-rev-hash2"></a><a href="https://www.npmjs.com/package/gulp-rev-hash2">gulp-rev-hash2</a></h4><p>这个插件是在引用的静态文件后面添加版本号的，这个版本号是被引用的文件的md5值，所以说这个插件和实用，不多说，直接上代码</p>
<p>gulpfile.js</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> gulp = <span class="built_in">require</span>(<span class="string">&#x27;gulp&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> rev = <span class="built_in">require</span>(<span class="string">&#x27;gulp-rev-hash2&#x27;</span>);</span><br><span class="line"> </span><br><span class="line">gulp.<span class="title function_">task</span>(<span class="string">&#x27;rev&#x27;</span>, <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    gulp.<span class="title function_">src</span>(<span class="string">&#x27;template.html&#x27;</span>)</span><br><span class="line">        .<span class="title function_">pipe</span>(<span class="title function_">rev</span>(&#123;</span><br><span class="line">          <span class="string">&#x27;cwd&#x27;</span>: <span class="string">&#x27;public/assets&#x27;</span>,</span><br><span class="line">          <span class="string">&#x27;suffix&#x27;</span>: <span class="string">&#x27;rev&#x27;</span>,</span><br><span class="line">          <span class="string">&#x27;fileTypes&#x27;</span>: [<span class="string">&#x27;css&#x27;</span>]</span><br><span class="line">        &#125;))</span><br><span class="line">        .<span class="title function_">pipe</span>(gulp.<span class="title function_">dest</span>(<span class="string">&#x27;.&#x27;</span>));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>输入:</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;main.min.css&quot;</span>/&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;abc.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;def.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>输出:</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;main.min.css?rev=9d58b7441d92130f545778e418d1317d&quot;</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;abc.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;def.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>用法也是很简单的，具体的可以看api</p>
<h4 id="gulp-file-concat"><a href="#gulp-file-concat" class="headerlink" title="gulp-file-concat"></a><a href="https://www.npmjs.com/package/gulp-file-concat">gulp-file-concat</a></h4><p>顾名思义，文件合并，这个插件可以合并通过document.write引入的js和通过@import引入的css，下面看一个例子：<br>index.js:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">document</span>.<span class="title function_">write</span>(<span class="string">&#x27;&lt;script src=&quot;a.js&quot;&gt;&lt;\/script&gt;&#x27;</span>);</span><br><span class="line">    <span class="variable language_">document</span>.<span class="title function_">write</span>(<span class="string">&#x27;&lt;script src=&quot;b.js&quot;&gt;&lt;\/script&gt;&#x27;</span>);</span><br><span class="line">&#125;());</span><br></pre></td></tr></table></figure>
<p>index.css:</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@import</span> url(<span class="string">&quot;a.css&quot;</span>);</span><br><span class="line"><span class="keyword">@import</span> url(<span class="string">&quot;b.css&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>gulpfile.js:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> gulp = <span class="built_in">require</span>(<span class="string">&#x27;gulp&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> fileconcat = <span class="built_in">require</span>(<span class="string">&#x27;gulp-file-concat&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> uglify = <span class="built_in">require</span>(<span class="string">&#x27;gulp-uglify&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> ngAnnotate = <span class="built_in">require</span>(<span class="string">&#x27;gulp-ng-annotate&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> rename = <span class="built_in">require</span>(<span class="string">&#x27;gulp-rename&#x27;</span>);</span><br><span class="line"></span><br><span class="line">gulp.<span class="title function_">task</span>(<span class="string">&#x27;default&#x27;</span>, <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  gulp.<span class="title function_">src</span>(<span class="string">&#x27;index.js&#x27;</span>)</span><br><span class="line">    .<span class="title function_">pipe</span>(<span class="title function_">fileconcat</span>(&#123;</span><br><span class="line">        <span class="attr">relativeUrls</span>: <span class="string">&#x27;./&#x27;</span></span><br><span class="line">    &#125;))</span><br><span class="line">    .<span class="title function_">pipe</span>(<span class="title function_">ngAnnotate</span>())</span><br><span class="line">    .<span class="title function_">pipe</span>(<span class="title function_">uglify</span>())</span><br><span class="line">    .<span class="title function_">pipe</span>(<span class="title function_">rename</span>(<span class="keyword">function</span>(<span class="params">path</span>)&#123;</span><br><span class="line">        path.<span class="property">basename</span> = <span class="string">&#x27;app&#x27;</span>;</span><br><span class="line">        path.<span class="property">extname</span> = <span class="string">&#x27;.js&#x27;</span></span><br><span class="line">    &#125;))</span><br><span class="line">    .<span class="title function_">pipe</span>(gulp.<span class="title function_">dest</span>(<span class="string">&#x27;build/&#x27;</span>));</span><br><span class="line"></span><br><span class="line">  gulp.<span class="title function_">src</span>(<span class="string">&#x27;index.css&#x27;</span>)</span><br><span class="line">      .<span class="title function_">pipe</span>(<span class="title function_">fileconcat</span>())</span><br><span class="line">      .<span class="title function_">pipe</span>(gulp.<span class="title function_">dest</span>(<span class="string">&#x27;build/&#x27;</span>));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>


<p>这个一个文件合并的插件，为什么要把这个插件放在这里来介绍，其实我觉得这个可以和<a href="https://www.npmjs.com/package/gulp-html-replace">gulp-html-replace</a>联合使用，至于怎么用，请细细品味吧</p>
<h3 id="Angular相关"><a href="#Angular相关" class="headerlink" title="Angular相关"></a>Angular相关</h3><p>这个部分介绍与Angular相关的一些插件。</p>
<h4 id="gulp-angular-templatecache"><a href="#gulp-angular-templatecache" class="headerlink" title="gulp-angular-templatecache"></a><a href="https://www.npmjs.com/package/gulp-angular-templatecache">gulp-angular-templatecache</a></h4><p>Angular自带的<code>$templateCache</code>服务可以把Angular中用到的所有模板缓存下来，而这个插件的功能就是直接将指定的HTML模板文件以JS字符串的形式注册在<code>$tempalteCache</code>服务中，这样所有的模板就会随JS文件直接一次性下载下来。这个插件使用起来也非常简单，gulp.src传入需要缓存的HTML模板文件，然后<code>.pipe($.angularTemplatecache(filename, options))</code>即可。其中filename表示生成后的js文件的名字，默认为templates.js，常用的options有：</p>
<ul>
<li><code>module</code>：指定希望将这个模板放入哪个Angular的module中。</li>
<li><code>root</code>：指定注册后的模板路径前缀。</li>
</ul>
<p>生成后的文件如下：</p>
<figure class="highlight javascript"><figcaption><span>templates.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">angular.<span class="title function_">module</span>(<span class="string">&quot;module name&quot;</span>).<span class="title function_">run</span>([$templateCache,</span><br><span class="line">  <span class="keyword">function</span>(<span class="params">$templateCache</span>) &#123;</span><br><span class="line">    $templateCache.<span class="title function_">put</span>(<span class="string">&quot;template1.html&quot;</span>,</span><br><span class="line">      <span class="comment">// template1.html content (escaped) </span></span><br><span class="line">    );</span><br><span class="line">    $templateCache.<span class="title function_">put</span>(<span class="string">&quot;template2.html&quot;</span>,</span><br><span class="line">      <span class="comment">// template2.html content (escaped) </span></span><br><span class="line">    );</span><br><span class="line">    <span class="comment">// etc. </span></span><br><span class="line">  &#125;</span><br><span class="line">]);</span><br></pre></td></tr></table></figure>

<h4 id="gulp-ng-annotate"><a href="#gulp-ng-annotate" class="headerlink" title="gulp-ng-annotate"></a><a href="https://www.npmjs.com/package/gulp-ng-annotate">gulp-ng-annotate</a></h4><p>这个插件是<a href="https://github.com/olov/ng-annotate">ng-annotate</a>的gulp插件版，它解决的是Angular中依赖注入的小问题。Angular中通过参数名来进行依赖注入，一旦压缩，参数名就会变化导致注入失败，所以官方推荐通过添加字符串进行注入。比如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">angular</span><br><span class="line">    .<span class="title function_">module</span>(<span class="string">&#x27;app.dashboard&#x27;</span>)</span><br><span class="line">    .<span class="title function_">controller</span>(<span class="string">&#x27;DashboardController&#x27;</span>, <span class="title class_">DashboardController</span>);</span><br><span class="line"></span><br><span class="line"><span class="title class_">DashboardController</span>.<span class="property">$inject</span> = [<span class="string">&#x27;userAPI&#x27;</span>];</span><br><span class="line"><span class="comment">/* @ngInject */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">DashboardController</span> (<span class="params">userAPI</span>) &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>上面的例子中我们定义了一个叫<code>DashboardController</code>的controller，它依赖一个<code>userAPI</code>的service。这个插件的作用就是根据第6行的注释<code>/* @ngInject */</code>来帮你生成第5行的内容。当然是在你忘记写的情况下，如果你自己写了它不会重复生成。除了这种使用<code>$inject</code>赋值的方式，它同样支持inline定义的方式，如</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* @ngInject */</span></span><br><span class="line">.<span class="title function_">controller</span>(<span class="string">&#x27;DashboardController&#x27;</span>, <span class="keyword">function</span> (<span class="params">userAPI</span>) &#123;&#125;);</span><br></pre></td></tr></table></figure>

<p>会生成</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.<span class="title function_">controller</span>(<span class="string">&#x27;DashboardController&#x27;</span>, [<span class="string">&#x27;userAPI&#x27;</span>, <span class="keyword">function</span> (<span class="params">userAPI</span>) &#123;&#125;]);</span><br></pre></td></tr></table></figure>

<p>它常用的参数就是<code>&#123;add: true&#125;</code>，表明仅在不存在的情况下才会进行添加。</p>
<blockquote>
<p>推荐在HTML头上使用<a href="https://docs.angularjs.org/error/$injector/strictdi">ng-strict-di</a>属性，这样即便在不压缩的情况下，一旦你忘记显式的用字符串声明依赖，Angular将立刻报错。</p>
</blockquote>
<h4 id="gulp-protractor"><a href="#gulp-protractor" class="headerlink" title="gulp-protractor"></a><a href="https://www.npmjs.com/package/gulp-protractor">gulp-protractor</a></h4><p>Angular的e2e测试工具<a href="https://github.com/angular/protractor">protractor</a>的配套插件，可以通过它非常方便的在gulp中调用protractor。有了这玩意，你就不需要手动在gulp中调用protractor的可执行文件，然后处理进程神马的，只要一句简单的<code>.pipe($.protractor.protractor(options)</code>即可。常用的options包括：</p>
<ul>
<li><code>configFile</code>：即protractor的配置文件路径。</li>
<li><code>args</code>：调用protractor时传入的参数，是个数组。最常用的就是指定protractor只跑一个suite了，如<code>[&#39;--suite&#39;, &#39;loginSuite&#39;]</code>，这样protractor只会跑配置文件中定义的loginSuite所包括的spec文件了。</li>
</ul>
<h4 id="gulp-order"><a href="#gulp-order" class="headerlink" title="gulp-order"></a><a href="https://www.npmjs.com/package/gulp-order">gulp-order</a></h4><p>这个插件严格来说不是专门给Angular用的，但非常适合用在Angular的场景下。如果你的程序使用的是Angular自带的包管理系统，那么有一个无法避开的问题就是：所有<code>angular.module</code>的定义要最先执行，也就是说包含module定义的文件的script标签要在别的文件之前。而我们在使用gulp-inject这类插件将JS文件插入的时候通常都是通过匹配符直接选中一堆文件插入的。这时就需要解决插入的顺序问题，而这个插件就是干这个事的。它通过一个数组参数来指定排序，这个数组包含一组匹配模式，匹配到靠前模式的文件在前，匹配靠后的文件在后。如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">gulp</span><br><span class="line">    .<span class="title function_">src</span>(<span class="string">&#x27;**/*.js&#x27;</span>)</span><br><span class="line">    .<span class="title function_">pipe</span>($.<span class="title function_">order</span>([</span><br><span class="line">        <span class="string">&#x27;**/app.module.js&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;**/*.module.js&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;**/*.js&#x27;</span></span><br><span class="line">    ]))</span><br></pre></td></tr></table></figure>

<p>这样，定义<code>app</code>module的文件就会在最前面，然后是其它各个module的定义，最后是剩余的JS文件。</p>
<h3 id="压缩工具类"><a href="#压缩工具类" class="headerlink" title="压缩工具类"></a>压缩工具类</h3><p>这个部分介绍对CSS、HTML、JS、图片等资源进行压缩的插件。</p>
<h4 id="gulp-csso"><a href="#gulp-csso" class="headerlink" title="gulp-csso"></a><a href="https://www.npmjs.com/package/gulp-csso">gulp-csso</a></h4><p>压缩CSS的工具，官方说它比其它工具压得更小，因为它可以重建CSS代码结构信息，不知道什么鬼。</p>
<h4 id="gulp-minify-html"><a href="#gulp-minify-html" class="headerlink" title="gulp-minify-html"></a><a href="https://www.npmjs.com/package/gulp-minify-html">gulp-minify-html</a></h4><p>压缩HTML的工具，通常在给gulp-angular-templatecache处理前先使用，这样$tempalteCache得到的就是压缩后的HTML字符串了。</p>
<h4 id="gulp-uglify"><a href="#gulp-uglify" class="headerlink" title="gulp-uglify"></a><a href="https://www.npmjs.com/package/gulp-uglify">gulp-uglify</a></h4><p>压缩JS的工具，这个不多介绍了。</p>
<h4 id="gulp-imagemin"><a href="#gulp-imagemin" class="headerlink" title="gulp-imagemin"></a><a href="https://www.npmjs.com/package/gulp-imagemin">gulp-imagemin</a></h4><p>压缩图片的工具。在发布到生产环境之前对图片进行压缩是一个非常好的习惯，可以极大的提高页面加载的速度。如果你用<a href="https://developers.google.com/speed/pagespeed/">Google PageSpeed</a>给网页评过分的话，它可以给出页面上能被继续压缩的图片。使用这个插件可以在保证质量损失很小的情况下压缩图片。</p>
<h3 id="server相关"><a href="#server相关" class="headerlink" title="server相关"></a>server相关</h3><p>这部分介绍与本地起server相关的插件。</p>
<h4 id="browser-sync"><a href="#browser-sync" class="headerlink" title="browser-sync"></a><a href="https://www.npmjs.com/package/browser-sync">browser-sync</a></h4><p><a href="http://www.browsersync.io/">Browsersync</a>应该算是本地起server的标配了吧，最大的特性是可以在不同浏览器之间同步（这也是名字的由来吧），这在测试时非常有用：起server以后根据配置自动打开多个浏览器，你操作一个，其他的浏览器会同步你的操作。另外，它还可以配合gulp的<code>watch()</code>函数实现类似live-reload的功能。之所以没有gulp对应的插件，是因为这玩意本来就可以直接require进来使用。支持非常多的参数，一整篇文章也介绍不完，具体可以参考<a href="http://www.browsersync.io/docs/options/">它的文档</a>。这里要简单介绍的就是server底下的配置，如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server</span>: &#123;</span><br><span class="line">    <span class="attr">baseDir</span>: <span class="string">&#x27;./app/&#x27;</span>,</span><br><span class="line">    <span class="attr">index</span>: <span class="string">&#x27;index.html&#x27;</span>,</span><br><span class="line">    <span class="attr">middleware</span>: [</span><br><span class="line">        <span class="comment">// middleware</span></span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>前两个参数就不多说了，一看就明白意思，重点来看第3个参数<code>middleware</code>。middleware就是中间件，类似这样的函数<code>function (req, res, next)&#123;&#125;</code>。简单来说，一个request请求到达server，会经过middleware数组里面的中间件函数逐个处理，这里就可以在Browsersync层面上定义很多自定义的操作。适用于Node的<a href="https://github.com/senchalabs/connect">connect框架</a>的中间件都可以在这里使用，下面介绍的两个插件都是可用于Browsersync的中间件。</p>
<h4 id="connect-history-api-fallback"><a href="#connect-history-api-fallback" class="headerlink" title="connect-history-api-fallback"></a><a href="https://www.npmjs.com/package/connect-history-api-fallback">connect-history-api-fallback</a></h4><p>这个中间件对于像Angular这样的单页面应用来说非常的实用。我们知道，Browsersync默认起来的server是一个静态server，默认是无法支持<code>$locationProvider.html5Mode(true);</code>的。使用这个插件可以轻松的达到这一点，如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> historyApiFallback = <span class="built_in">require</span>(<span class="string">&#x27;connect-history-api-fallback&#x27;</span>);</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="attr">middleware</span>: [</span><br><span class="line">    <span class="title function_">historyApiFallback</span>()</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>这样，所有的路由请求都会fallback到index.html处理，这也正是我们想要的。除此之外，这个插件还支持简单的rewrite，如</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">historyApiFallback</span>(&#123;</span><br><span class="line">  <span class="attr">rewrites</span>: [</span><br><span class="line">    &#123; <span class="attr">from</span>: <span class="regexp">/\/soccer/</span>, <span class="attr">to</span>: <span class="string">&#x27;/soccer.html&#x27;</span>&#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>可谓是非常方便，更多的rewrite规则可以参考它的文档。</p>
<h4 id="proxy-middleware"><a href="#proxy-middleware" class="headerlink" title="proxy-middleware"></a><a href="https://www.npmjs.com/package/proxy-middleware">proxy-middleware</a></h4><p>这个中间件其实与上面rewrite的类似，只不过rewrite只是针对get请求，而这个proxy可以代理任何请求。设想这样一个场景，我们起了个本地的server，通常使用<a href="https://docs.angularjs.org/api/ngMock">ngMock</a>来实现对API的模拟，但有的时候我们希望这个本地的server可以对接真正的API server，而这个中间件可以轻松的完成这一点：将<code>/api</code>开头的请求代理到真正的API server上去。它的使用也是非常简单：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> proxy = <span class="built_in">require</span>(<span class="string">&#x27;proxy-middleware&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> proxyOptions = url.<span class="title function_">parse</span>(<span class="string">&#x27;https://real-server.com/api&#x27;</span>);</span><br><span class="line">proxyOptions.<span class="property">route</span> = <span class="string">&#x27;/api&#x27;</span>;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="attr">middleware</span>: [</span><br><span class="line">    <span class="title function_">proxy</span>(proxyOptions)</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>这样，所有以<code>/api</code>开头的API请求就会被代理到<code>https://real-server.com/api</code>上去，如<code>/api/user/123</code>请求的真实地址是<code>https://real-server.com/api/user/123</code>。</p>
<h3 id="特定语言相关"><a href="#特定语言相关" class="headerlink" title="特定语言相关"></a>特定语言相关</h3><p>这部分的插件与你选用的具体的语言以及预处理器有关。</p>
<h4 id="gulp-jshint-与-gulp-jscs"><a href="#gulp-jshint-与-gulp-jscs" class="headerlink" title="gulp-jshint 与 gulp-jscs"></a><a href="https://www.npmjs.com/package/gulp-jshint">gulp-jshint</a> 与 <a href="https://www.npmjs.com/package/gulp-jscs">gulp-jscs</a></h4><p>大名鼎鼎的<a href="">jshint</a>和<a href="">jscs</a>的gulp插件版。这两个插件除了帮你做代码的一些静态检查外，还可以最大程度的帮助你定义所需要的代码风格。尤其是<code>jscs</code>，定义的非常细致。比如我们需要<code>function (a, b) &#123;</code>，即function关键字后面空一格，参数之间空一格，参数列表后面的小括号与大括号之间空一格。这样的需求通过<code>jscs</code>的配置文件可以轻松的实现，具体可以参考其文档。可以将这两个task放在build之前，强制所有人在build代码的时候修改不符合要求的代码风格。我们还尝试过将<code>gulp jshint jscs</code>放入git commit的hook中，每次commit的时候自动检查代码风格，如果不符合要求，不准进行commit的操作。</p>
<h4 id="gulp-jade"><a href="#gulp-jade" class="headerlink" title="gulp-jade"></a><a href="https://www.npmjs.com/package/gulp-jade">gulp-jade</a></h4><p>编译jade模板的插件，这个也不过多介绍。只介绍一个使用jade变量的场景，通常我们的Angular应用的<code>ng-app</code>名称在测试(e2e)与非测试时是不一样的，所以可以把这个定义成变量，在编译jade模板时传入。如我们的index.jade的头是这样定义的<code>html(lang=&quot;en&quot;, ng-app= app)</code>，在编译时使用<code>.pipe($.jade(&#123;locals: &#123;app: &#39;test&#39;&#125;&#125;))</code>即可指定想要的<code>ng-app</code>的名字。</p>
<h4 id="gulp-stylus"><a href="#gulp-stylus" class="headerlink" title="gulp-stylus"></a><a href="https://www.npmjs.com/package/gulp-stylus">gulp-stylus</a></h4><p>编译stylus的插件，不多说。</p>
<h4 id="gulp-autoprefixer"><a href="#gulp-autoprefixer" class="headerlink" title="gulp-autoprefixer"></a><a href="https://www.npmjs.com/package/gulp-autoprefixer">gulp-autoprefixer</a></h4><p>这个插件最早在<a href="/2014/01/12/what-i-learn-from-making-resume/">从做简历中学到的知识</a>这篇文章中就介绍过，只不过当时介绍的是grunt版本，现在时gulp版本。这个插件的基本作用就是让你在书写CSS3的相关属性时不用关心不同浏览器的前缀问题，它会自动帮助添加各种浏览器前缀。</p>

        </div>
    
<!-- tags -->

    <div class="post-meta">
        标签：
        
            <a href="/tags/javascript/"> / javascript</a>
        
    </div>

</div>
                <div class="footer">
    <span>Copyright © <script>document.write(new Date().getFullYear())</script> 白云雅阁</span>
    <span>Powered by <a href="https://hexo.io">Hexo</a> with <a href="https:///imzl.com/zenmind">ZenMind</a></span>
    <span>备案号<a href="https://beian.miit.gov.cn/" target="_blank">京ICP备2024093046号-1</a></span>
</div>

<link rel="stylesheet" href="/css/a11y-dark.min.css">


<script src="/js/highlight.min.js"></script>


<script src="/js/highlightjs-line-numbers.js"></script>

<script>
    hljs.initHighlightingOnLoad();
    hljs.initLineNumbersOnLoad();
</script>

            </div>
        </div>
    </body>
</html>